-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.Query exposing (..)

import Api.Enum.CountryInfosOrderBy
import Api.Enum.TransactionsOrderBy
import Api.Enum.UsersOrderBy
import Api.Enum.WeatherDataOrderBy
import Api.InputObject
import Api.Interface
import Api.Object
import Api.Scalar
import Api.ScalarCodecs
import Api.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


{-| Exposes the root query type nested one level down. This is helpful for Relay 1
which can only query top level fields if they are in a particular form.
-}
query :
    SelectionSet decodesTo RootQuery
    -> SelectionSet decodesTo RootQuery
query object____ =
    Object.selectionForCompositeField "query" [] object____ Basics.identity


{-| The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
-}
nodeId : SelectionSet Api.ScalarCodecs.Id RootQuery
nodeId =
    Object.selectionForField "ScalarCodecs.Id" "nodeId" [] (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapCodecs |> .codecId |> .decoder)


type alias NodeRequiredArguments =
    { nodeId : Api.ScalarCodecs.Id }


{-| Fetches an object given its globally unique `ID`.

  - nodeId - The globally unique `ID`.

-}
node :
    NodeRequiredArguments
    -> SelectionSet decodesTo Api.Interface.Node
    -> SelectionSet (Maybe decodesTo) RootQuery
node requiredArgs____ object____ =
    Object.selectionForCompositeField "node" [ Argument.required "nodeId" requiredArgs____.nodeId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias AllCountryInfosOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , offset : OptionalArgument Int
    , before : OptionalArgument Api.ScalarCodecs.Cursor
    , after : OptionalArgument Api.ScalarCodecs.Cursor
    , orderBy : OptionalArgument (List Api.Enum.CountryInfosOrderBy.CountryInfosOrderBy)
    , condition : OptionalArgument Api.InputObject.CountryInfoCondition
    }


{-| Reads and enables pagination through a set of `CountryInfo`.

  - first - Only read the first `n` values of the set.
  - last - Only read the last `n` values of the set.
  - offset - Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
  - before - Read all values in the set before (above) this cursor.
  - after - Read all values in the set after (below) this cursor.
  - orderBy - The method to use when ordering `CountryInfo`.
  - condition - A condition to be used in determining which values should be returned by the collection.

-}
allCountryInfos :
    (AllCountryInfosOptionalArguments -> AllCountryInfosOptionalArguments)
    -> SelectionSet decodesTo Api.Object.CountryInfosConnection
    -> SelectionSet (Maybe decodesTo) RootQuery
allCountryInfos fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, last = Absent, offset = Absent, before = Absent, after = Absent, orderBy = Absent, condition = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "before" filledInOptionals____.before (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecCursor), Argument.optional "after" filledInOptionals____.after (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecCursor), Argument.optional "orderBy" filledInOptionals____.orderBy (Encode.enum Api.Enum.CountryInfosOrderBy.toString |> Encode.list), Argument.optional "condition" filledInOptionals____.condition Api.InputObject.encodeCountryInfoCondition ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "allCountryInfos" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias AllTransactionsOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , offset : OptionalArgument Int
    , before : OptionalArgument Api.ScalarCodecs.Cursor
    , after : OptionalArgument Api.ScalarCodecs.Cursor
    , orderBy : OptionalArgument (List Api.Enum.TransactionsOrderBy.TransactionsOrderBy)
    , condition : OptionalArgument Api.InputObject.TransactionCondition
    }


{-| Reads and enables pagination through a set of `Transaction`.

  - first - Only read the first `n` values of the set.
  - last - Only read the last `n` values of the set.
  - offset - Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
  - before - Read all values in the set before (above) this cursor.
  - after - Read all values in the set after (below) this cursor.
  - orderBy - The method to use when ordering `Transaction`.
  - condition - A condition to be used in determining which values should be returned by the collection.

-}
allTransactions :
    (AllTransactionsOptionalArguments -> AllTransactionsOptionalArguments)
    -> SelectionSet decodesTo Api.Object.TransactionsConnection
    -> SelectionSet (Maybe decodesTo) RootQuery
allTransactions fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, last = Absent, offset = Absent, before = Absent, after = Absent, orderBy = Absent, condition = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "before" filledInOptionals____.before (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecCursor), Argument.optional "after" filledInOptionals____.after (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecCursor), Argument.optional "orderBy" filledInOptionals____.orderBy (Encode.enum Api.Enum.TransactionsOrderBy.toString |> Encode.list), Argument.optional "condition" filledInOptionals____.condition Api.InputObject.encodeTransactionCondition ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "allTransactions" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias AllUsersOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , offset : OptionalArgument Int
    , before : OptionalArgument Api.ScalarCodecs.Cursor
    , after : OptionalArgument Api.ScalarCodecs.Cursor
    , orderBy : OptionalArgument (List Api.Enum.UsersOrderBy.UsersOrderBy)
    , condition : OptionalArgument Api.InputObject.UserCondition
    }


{-| Reads and enables pagination through a set of `User`.

  - first - Only read the first `n` values of the set.
  - last - Only read the last `n` values of the set.
  - offset - Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
  - before - Read all values in the set before (above) this cursor.
  - after - Read all values in the set after (below) this cursor.
  - orderBy - The method to use when ordering `User`.
  - condition - A condition to be used in determining which values should be returned by the collection.

-}
allUsers :
    (AllUsersOptionalArguments -> AllUsersOptionalArguments)
    -> SelectionSet decodesTo Api.Object.UsersConnection
    -> SelectionSet (Maybe decodesTo) RootQuery
allUsers fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, last = Absent, offset = Absent, before = Absent, after = Absent, orderBy = Absent, condition = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "before" filledInOptionals____.before (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecCursor), Argument.optional "after" filledInOptionals____.after (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecCursor), Argument.optional "orderBy" filledInOptionals____.orderBy (Encode.enum Api.Enum.UsersOrderBy.toString |> Encode.list), Argument.optional "condition" filledInOptionals____.condition Api.InputObject.encodeUserCondition ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "allUsers" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias AllWeatherDataOptionalArguments =
    { first : OptionalArgument Int
    , last : OptionalArgument Int
    , offset : OptionalArgument Int
    , before : OptionalArgument Api.ScalarCodecs.Cursor
    , after : OptionalArgument Api.ScalarCodecs.Cursor
    , orderBy : OptionalArgument (List Api.Enum.WeatherDataOrderBy.WeatherDataOrderBy)
    , condition : OptionalArgument Api.InputObject.WeatherDatumCondition
    }


{-| Reads and enables pagination through a set of `WeatherDatum`.

  - first - Only read the first `n` values of the set.
  - last - Only read the last `n` values of the set.
  - offset - Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
  - before - Read all values in the set before (above) this cursor.
  - after - Read all values in the set after (below) this cursor.
  - orderBy - The method to use when ordering `WeatherDatum`.
  - condition - A condition to be used in determining which values should be returned by the collection.

-}
allWeatherData :
    (AllWeatherDataOptionalArguments -> AllWeatherDataOptionalArguments)
    -> SelectionSet decodesTo Api.Object.WeatherDataConnection
    -> SelectionSet (Maybe decodesTo) RootQuery
allWeatherData fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, last = Absent, offset = Absent, before = Absent, after = Absent, orderBy = Absent, condition = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "before" filledInOptionals____.before (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecCursor), Argument.optional "after" filledInOptionals____.after (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecCursor), Argument.optional "orderBy" filledInOptionals____.orderBy (Encode.enum Api.Enum.WeatherDataOrderBy.toString |> Encode.list), Argument.optional "condition" filledInOptionals____.condition Api.InputObject.encodeWeatherDatumCondition ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "allWeatherData" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias CountryInfoByIdRequiredArguments =
    { id : Int }


countryInfoById :
    CountryInfoByIdRequiredArguments
    -> SelectionSet decodesTo Api.Object.CountryInfo
    -> SelectionSet (Maybe decodesTo) RootQuery
countryInfoById requiredArgs____ object____ =
    Object.selectionForCompositeField "countryInfoById" [ Argument.required "id" requiredArgs____.id Encode.int ] object____ (Basics.identity >> Decode.nullable)


type alias TransactionByIdRequiredArguments =
    { id : Int }


transactionById :
    TransactionByIdRequiredArguments
    -> SelectionSet decodesTo Api.Object.Transaction
    -> SelectionSet (Maybe decodesTo) RootQuery
transactionById requiredArgs____ object____ =
    Object.selectionForCompositeField "transactionById" [ Argument.required "id" requiredArgs____.id Encode.int ] object____ (Basics.identity >> Decode.nullable)


type alias UserByIdRequiredArguments =
    { id : Int }


userById :
    UserByIdRequiredArguments
    -> SelectionSet decodesTo Api.Object.User
    -> SelectionSet (Maybe decodesTo) RootQuery
userById requiredArgs____ object____ =
    Object.selectionForCompositeField "userById" [ Argument.required "id" requiredArgs____.id Encode.int ] object____ (Basics.identity >> Decode.nullable)


type alias UserByUsernameRequiredArguments =
    { username : String }


userByUsername :
    UserByUsernameRequiredArguments
    -> SelectionSet decodesTo Api.Object.User
    -> SelectionSet (Maybe decodesTo) RootQuery
userByUsername requiredArgs____ object____ =
    Object.selectionForCompositeField "userByUsername" [ Argument.required "username" requiredArgs____.username Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias UserByEmailRequiredArguments =
    { email : String }


userByEmail :
    UserByEmailRequiredArguments
    -> SelectionSet decodesTo Api.Object.User
    -> SelectionSet (Maybe decodesTo) RootQuery
userByEmail requiredArgs____ object____ =
    Object.selectionForCompositeField "userByEmail" [ Argument.required "email" requiredArgs____.email Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias WeatherDatumByIdRequiredArguments =
    { id : Int }


weatherDatumById :
    WeatherDatumByIdRequiredArguments
    -> SelectionSet decodesTo Api.Object.WeatherDatum
    -> SelectionSet (Maybe decodesTo) RootQuery
weatherDatumById requiredArgs____ object____ =
    Object.selectionForCompositeField "weatherDatumById" [ Argument.required "id" requiredArgs____.id Encode.int ] object____ (Basics.identity >> Decode.nullable)


type alias CountryInfoRequiredArguments =
    { nodeId : Api.ScalarCodecs.Id }


{-| Reads a single `CountryInfo` using its globally unique `ID`.

  - nodeId - The globally unique `ID` to be used in selecting a single `CountryInfo`.

-}
countryInfo :
    CountryInfoRequiredArguments
    -> SelectionSet decodesTo Api.Object.CountryInfo
    -> SelectionSet (Maybe decodesTo) RootQuery
countryInfo requiredArgs____ object____ =
    Object.selectionForCompositeField "countryInfo" [ Argument.required "nodeId" requiredArgs____.nodeId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias TransactionRequiredArguments =
    { nodeId : Api.ScalarCodecs.Id }


{-| Reads a single `Transaction` using its globally unique `ID`.

  - nodeId - The globally unique `ID` to be used in selecting a single `Transaction`.

-}
transaction :
    TransactionRequiredArguments
    -> SelectionSet decodesTo Api.Object.Transaction
    -> SelectionSet (Maybe decodesTo) RootQuery
transaction requiredArgs____ object____ =
    Object.selectionForCompositeField "transaction" [ Argument.required "nodeId" requiredArgs____.nodeId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias UserRequiredArguments =
    { nodeId : Api.ScalarCodecs.Id }


{-| Reads a single `User` using its globally unique `ID`.

  - nodeId - The globally unique `ID` to be used in selecting a single `User`.

-}
user :
    UserRequiredArguments
    -> SelectionSet decodesTo Api.Object.User
    -> SelectionSet (Maybe decodesTo) RootQuery
user requiredArgs____ object____ =
    Object.selectionForCompositeField "user" [ Argument.required "nodeId" requiredArgs____.nodeId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias WeatherDatumRequiredArguments =
    { nodeId : Api.ScalarCodecs.Id }


{-| Reads a single `WeatherDatum` using its globally unique `ID`.

  - nodeId - The globally unique `ID` to be used in selecting a single `WeatherDatum`.

-}
weatherDatum :
    WeatherDatumRequiredArguments
    -> SelectionSet decodesTo Api.Object.WeatherDatum
    -> SelectionSet (Maybe decodesTo) RootQuery
weatherDatum requiredArgs____ object____ =
    Object.selectionForCompositeField "weatherDatum" [ Argument.required "nodeId" requiredArgs____.nodeId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)
